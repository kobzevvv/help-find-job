/**
 * Telegram conversation handlers
 */

import { TelegramMessage } from '../types/telegram';
import { SessionService } from '../services/session';
import { TelegramService } from '../services/telegram';
import { DocumentService } from '../services/document';
import { AIService } from '../services/ai';
import { EnhancedAIService } from '../services/enhanced-ai';
import { LoggingService } from '../services/logging';
import { EnhancedAnalysis } from '../types/session';

export class ConversationHandler {
  private sessionService: SessionService;
  private telegramService: TelegramService;
  private documentService: DocumentService;
  private enhancedAIService: EnhancedAIService;
  private loggingService: LoggingService;
  private environment: string;
  private adminPassword: string;

  constructor(
    sessionService: SessionService,
    telegramService: TelegramService,
    documentService: DocumentService,
    _aiService: AIService, // Keep parameter for backwards compatibility
    enhancedAIService: EnhancedAIService,
    loggingService: LoggingService,
    environment: string = 'development',
    adminPassword: string = 'defaultpassword'
  ) {
    this.sessionService = sessionService;
    this.telegramService = telegramService;
    this.documentService = documentService;
    // aiService parameter kept for backwards compatibility but not stored
    this.enhancedAIService = enhancedAIService;
    this.loggingService = loggingService;
    this.environment = environment;
    this.adminPassword = adminPassword;
  }

  /**
   * Handle incoming message
   */
  async handleMessage(message: TelegramMessage): Promise<void> {
    const userId = message.from?.id;
    const chatId = message.chat.id;

    console.log('üéØ CONVERSATION HANDLER:', {
      userId,
      chatId,
      text: message.text,
      hasFrom: !!message.from,
      timestamp: new Date().toISOString()
    });

    if (!userId) {
      console.error('‚ùå Missing user ID in message');
      await this.loggingService.logError('INVALID_MESSAGE', 'No user ID in message', new Error('Missing user ID'), undefined, chatId);
      return;
    }

    const messageText = message.text || message.document?.file_name || 'non-text message';
    await this.loggingService.logUserMessage(userId, chatId, messageText, {
      messageId: message.message_id,
      messageType: message.text ? 'text' : message.document ? 'document' : 'other',
      documentInfo: message.document ? {
        fileName: message.document.file_name,
        mimeType: message.document.mime_type,
        fileSize: message.document.file_size
      } : undefined
    });

    try {
      // Get or create session
      let session = await this.sessionService.getSession(userId);
      if (!session) {
        await this.loggingService.log('INFO', 'NEW_SESSION', 'Creating new session for user', { userId, chatId });
        session = this.sessionService.createSession(
          userId,
          chatId,
          message.from?.language_code
        );
        await this.sessionService.saveSession(session);
      } else {
        await this.loggingService.log('DEBUG', 'SESSION_FOUND', `Found existing session in state: ${session.state}`, { 
          userId, 
          chatId, 
          currentState: session.state,
          sessionAge: new Date().getTime() - new Date(session.createdAt).getTime()
        });
      }

      // Handle different message types based on session state
      if (message.text) {
        await this.handleTextMessage(message, session.state);
      } else if (message.document) {
        await this.handleDocumentMessage(message, session.state);
      } else {
        await this.loggingService.log('WARN', 'UNSUPPORTED_MESSAGE', 'Received unsupported message type', { messageType: typeof message }, userId, chatId);
        await this.sendHelpMessage(chatId);
      }

    } catch (error) {
      console.error('üí• MESSAGE HANDLER ERROR:', error);
      await this.loggingService.logError('MESSAGE_HANDLER_ERROR', 'Error in message handler', error as Error, userId, chatId);
      await this.telegramService.sendMessage({
        chat_id: chatId,
        text: '‚ùå Sorry, something went wrong. Please try again.',
      });
    }
  }

  /**
   * Handle text messages
   */
  private async handleTextMessage(message: TelegramMessage, currentState: string): Promise<void> {
    const chatId = message.chat.id;
    const userId = message.from!.id;
    const text = message.text!;

    // No more admin login state to handle - simplified!

    // Handle commands
    if (text.startsWith('/')) {
      await this.handleCommand(text, chatId, userId);
      return;
    }

    // Handle conversation flow
    switch (currentState) {
      case 'idle':
        if (this.isMatchRequest(text)) {
          await this.startMatchingProcess(chatId, userId);
        } else {
          await this.sendHelpMessage(chatId);
        }
        break;

      case 'waiting_resume':
        await this.handleResumeText(text, chatId, userId);
        break;

      case 'waiting_job_post':
        await this.handleJobPostText(text, chatId, userId);
        break;

      case 'processing':
        await this.telegramService.sendMessage({
          chat_id: chatId,
          text: '‚è≥ Please wait, I\'m still processing your documents...',
        });
        break;

      default:
        await this.sendHelpMessage(chatId);
    }
  }

  /**
   * Handle document uploads
   */
  private async handleDocumentMessage(message: TelegramMessage, currentState: string): Promise<void> {
    const chatId = message.chat.id;
    const userId = message.from!.id;
    const document = message.document!;

    if (currentState !== 'waiting_resume' && currentState !== 'waiting_job_post') {
      await this.telegramService.sendMessage({
        chat_id: chatId,
        text: '‚ùå I\'m not expecting a document right now. Please start with /resume_and_job_post_match',
      });
      return;
    }

    try {
      // Download and process document
      const fileInfo = await this.telegramService.getFile(document.file_id);
      if (!fileInfo?.file_path) {
        throw new Error('Could not get file information');
      }

      const fileContent = await this.telegramService.downloadFile(fileInfo.file_path);
      if (!fileContent) {
        throw new Error('Could not download file');
      }

      const processedDocument = await this.documentService.processDocument(
        fileContent,
        document.file_name,
        document.mime_type
      );

      if (!processedDocument) {
        throw new Error('Could not process document');
      }

      const validation = this.documentService.validateDocument(processedDocument);
      if (!validation.isValid) {
        await this.telegramService.sendMessage({
          chat_id: chatId,
          text: `‚ùå ${validation.error}`,
        });
        return;
      }

      // Save document to session
      if (currentState === 'waiting_resume') {
        await this.sessionService.addResume(userId, processedDocument);
        await this.telegramService.sendMessage({
          chat_id: chatId,
          text: '‚úÖ Resume received! Now please send me the job posting (you can copy and paste the text).',
        });
      } else if (currentState === 'waiting_job_post') {
        await this.sessionService.addJobPost(userId, processedDocument);
        await this.startAnalysis(chatId, userId);
      }

    } catch (error) {
      console.error('Error processing document:', error);
      await this.telegramService.sendMessage({
        chat_id: chatId,
        text: `‚ùå Sorry, I couldn't process that document: ${error}. Please try copying and pasting the text instead.`,
      });
    }
  }

  /**
   * Handle bot commands
   */
  private async handleCommand(fullText: string, chatId: number, userId: number): Promise<void> {
    const parts = fullText.trim().split(/\s+/);
    const command = parts.length > 0 && parts[0] ? parts[0].toLowerCase() : '';
    switch (command) {
      case '/start':
        await this.sendWelcomeMessage(chatId);
        break;

      case '/resume_and_job_post_match':
        await this.startMatchingProcess(chatId, userId);
        break;

      case '/help':
        await this.sendHelpMessage(chatId);
        break;

      case '/cancel':
        await this.cancelCurrentProcess(chatId, userId);
        break;

      // Admin/Log commands (simplified - just ask for password)
      case '/get_last_10_messages':
      case '/logs':
        await this.handleSimpleLogCommand(fullText, chatId, userId, 10);
        break;

      case '/get_last_100_messages':
        await this.handleSimpleLogCommand(fullText, chatId, userId, 100);
        break;

      case '/get_last_300_messages':
        await this.handleSimpleLogCommand(fullText, chatId, userId, 300);
        break;

      case '/log_summary':
        await this.handleSimpleLogSummaryCommand(fullText, chatId, userId);
        break;

      case '/test_resume_match':
        await this.handleTestResumeMatch(chatId, userId);
        break;

      default:
        await this.sendHelpMessage(chatId);
    }
  }

  /**
   * Check if text is a matching request
   */
  private isMatchRequest(text: string): boolean {
    const lowerText = text.toLowerCase();
    const keywords = [
      'help match', 'match resume', 'compare resume', 'analyze resume',
      'job match', 'resume job', 'check resume'
    ];
    return keywords.some(keyword => lowerText.includes(keyword));
  }

  /**
   * Start the matching process
   */
  private async startMatchingProcess(chatId: number, userId: number): Promise<void> {
    await this.sessionService.updateState(userId, 'waiting_resume');
    await this.telegramService.sendMessage({
      chat_id: chatId,
      text: 'üìÑ I\'ll help you analyze how well your resume matches a job description!\n\nPlease send me your resume first. You can:\n‚Ä¢ Upload a PDF or DOCX file\n‚Ä¢ Copy and paste the text directly\n\nüí° Tip: Text format usually works better!',
    });
  }

  /**
   * Handle resume text input
   */
  private async handleResumeText(text: string, chatId: number, userId: number): Promise<void> {
    try {
      const processedDocument = this.documentService.processTextInput(text);
      const validation = this.documentService.validateDocument(processedDocument);

      if (!validation.isValid) {
        await this.telegramService.sendMessage({
          chat_id: chatId,
          text: `‚ùå ${validation.error}`,
        });
        return;
      }

      await this.sessionService.addResume(userId, processedDocument);
      await this.telegramService.sendMessage({
        chat_id: chatId,
        text: '‚úÖ Resume received! Now please send me the job posting text.',
      });

    } catch (error) {
      console.error('Error processing resume text:', error);
      await this.telegramService.sendMessage({
        chat_id: chatId,
        text: '‚ùå Sorry, I couldn\'t process that text. Please try again.',
      });
    }
  }

  /**
   * Handle job post text input
   */
  private async handleJobPostText(text: string, chatId: number, userId: number): Promise<void> {
    try {
      const processedDocument = this.documentService.processTextInput(text);
      const validation = this.documentService.validateDocument(processedDocument);

      if (!validation.isValid) {
        await this.telegramService.sendMessage({
          chat_id: chatId,
          text: `‚ùå ${validation.error}`,
        });
        return;
      }

      await this.sessionService.addJobPost(userId, processedDocument);
      await this.startAnalysis(chatId, userId);

    } catch (error) {
      console.error('Error processing job post text:', error);
      await this.telegramService.sendMessage({
        chat_id: chatId,
        text: '‚ùå Sorry, I couldn\'t process that text. Please try again.',
      });
    }
  }

  /**
   * Start AI analysis using enhanced service
   */
  private async startAnalysis(chatId: number, userId: number): Promise<void> {
    await this.telegramService.sendMessage({
      chat_id: chatId,
      text: 'üîÑ Performing comprehensive resume analysis...\n\nThis will analyze:\n‚Ä¢ Headlines & Job Titles\n‚Ä¢ Skills Match\n‚Ä¢ Experience Alignment\n‚Ä¢ Job Conditions\n\nThis may take 60-90 seconds.',
    });

    try {
      const session = await this.sessionService.getSession(userId);
      if (!session?.resume || !session?.jobPost) {
        throw new Error('Missing resume or job post data');
      }

      console.log('Starting enhanced analysis for user:', userId);
      const enhancedAnalysis = await this.enhancedAIService.analyzeResumeJobMatch(session.resume, session.jobPost);
      
      if (!enhancedAnalysis) {
        throw new Error('Enhanced analysis failed');
      }

      await this.sendEnhancedAnalysisResults(chatId, enhancedAnalysis);
      await this.sessionService.completeSession(userId);

    } catch (error) {
      console.error('Error during enhanced analysis:', error);
      await this.telegramService.sendMessage({
        chat_id: chatId,
        text: '‚ùå Sorry, the analysis failed. Please try again later.\n\nError details: ' + (error as Error).message,
      });
      await this.sessionService.completeSession(userId);
    }
  }

  /**
   * Send enhanced analysis results
   */
  private async sendEnhancedAnalysisResults(chatId: number, analysis: EnhancedAnalysis): Promise<void> {
    // Send summary first
    await this.telegramService.sendMessage({
      chat_id: chatId,
      text: `üìä **COMPREHENSIVE RESUME ANALYSIS**\n\n${analysis.summary}\n\nüìà **Overall Match Score: ${analysis.overallScore}/100**`,
      parse_mode: 'Markdown',
    });

    // Send detailed breakdown in separate messages to avoid length limits
    await this.sendHeadlineAnalysis(chatId, analysis.headlines);
    await this.sendSkillsAnalysis(chatId, analysis.skills);
    await this.sendExperienceAnalysis(chatId, analysis.experience);
    await this.sendJobConditionsAnalysis(chatId, analysis.jobConditions);

    // Send final message
    await this.telegramService.sendMessage({
      chat_id: chatId,
      text: 'üí° **Want to analyze another job posting?** Just send /resume_and_job_post_match again!\n\nüî¨ **For testing?** Use the test files in /tests folder.',
    });
  }

  /**
   * Send headline analysis details
   */
  private async sendHeadlineAnalysis(chatId: number, headlines: any): Promise<void> {
    const message = `üè∑Ô∏è **HEADLINES ANALYSIS** (${headlines.matchScore}/100)

**Job Title:** ${headlines.jobTitle}
**Your Titles:** ${headlines.candidateTitles.join(', ')}

**Analysis:** ${headlines.explanation}

${headlines.problems.length > 0 ? `üö® **Issues:**\n${headlines.problems.map((p: string) => `‚Ä¢ ${p}`).join('\n')}` : ''}

${headlines.recommendations.length > 0 ? `üí° **Recommendations:**\n${headlines.recommendations.map((r: string) => `‚Ä¢ ${r}`).join('\n')}` : ''}`;

    await this.telegramService.sendMessage({
      chat_id: chatId,
      text: message,
      parse_mode: 'Markdown',
    });
  }

  /**
   * Send skills analysis details
   */
  private async sendSkillsAnalysis(chatId: number, skills: any): Promise<void> {
    const message = `üõ†Ô∏è **SKILLS ANALYSIS** (${skills.matchScore}/100)

**Requested Skills:** ${skills.requestedSkills.join(', ')}
**Your Skills:** ${skills.candidateSkills.join(', ')}
**‚úÖ Matching:** ${skills.matchingSkills.join(', ')}
**‚ùå Missing:** ${skills.missingSkills.join(', ')}
**‚ûï Additional:** ${skills.additionalSkills.join(', ')}

**Analysis:** ${skills.explanation}

${skills.problems.length > 0 ? `üö® **Issues:**\n${skills.problems.map((p: string) => `‚Ä¢ ${p}`).join('\n')}` : ''}

${skills.recommendations.length > 0 ? `üí° **Recommendations:**\n${skills.recommendations.map((r: string) => `‚Ä¢ ${r}`).join('\n')}` : ''}`;

    await this.telegramService.sendMessage({
      chat_id: chatId,
      text: message,
      parse_mode: 'Markdown',
    });
  }

  /**
   * Send experience analysis details
   */
  private async sendExperienceAnalysis(chatId: number, experience: any): Promise<void> {
    const seniorityEmoji = experience.seniorityMatch === 'perfect-match' ? '‚úÖ' : 
                          experience.seniorityMatch === 'over-qualified' ? '‚¨ÜÔ∏è' : '‚¨áÔ∏è';

    const message = `üíº **EXPERIENCE ANALYSIS** (${experience.experienceMatch}/100)

**Your Experience:** ${experience.candidateExperience.join(', ')}
**Job Requirements:** ${experience.jobRequirements.join(', ')}

**Seniority Match:** ${seniorityEmoji} ${experience.seniorityMatch}
${experience.seniorityExplanation}

**Quantity Match:** ${experience.quantityMatch}/100
${experience.quantityExplanation}

**Analysis:** ${experience.explanation}

${experience.problems.length > 0 ? `üö® **Issues:**\n${experience.problems.map((p: string) => `‚Ä¢ ${p}`).join('\n')}` : ''}

${experience.recommendations.length > 0 ? `üí° **Recommendations:**\n${experience.recommendations.map((r: string) => `‚Ä¢ ${r}`).join('\n')}` : ''}`;

    await this.telegramService.sendMessage({
      chat_id: chatId,
      text: message,
      parse_mode: 'Markdown',
    });
  }

  /**
   * Send job conditions analysis details
   */
  private async sendJobConditionsAnalysis(chatId: number, conditions: any): Promise<void> {
    const locationEmoji = conditions.location.compatible ? '‚úÖ' : '‚ùå';
    const salaryEmoji = conditions.salary.compatible ? '‚úÖ' : '‚ùå';
    const scheduleEmoji = conditions.schedule.compatible ? '‚úÖ' : '‚ùå';
    const formatEmoji = conditions.workFormat.compatible ? '‚úÖ' : '‚ùå';

    const message = `üìç **JOB CONDITIONS ANALYSIS** (${conditions.overallScore}/100)

${locationEmoji} **Location:** ${conditions.location.jobLocation} vs ${conditions.location.candidateLocation}
${conditions.location.explanation}

${salaryEmoji} **Salary:** ${conditions.salary.jobSalary} vs ${conditions.salary.candidateExpectation}
${conditions.salary.explanation}

${scheduleEmoji} **Schedule:** ${conditions.schedule.jobSchedule} vs ${conditions.schedule.candidatePreference}
${conditions.schedule.explanation}

${formatEmoji} **Work Format:** ${conditions.workFormat.jobFormat} vs ${conditions.workFormat.candidatePreference}
${conditions.workFormat.explanation}

**Overall Assessment:** ${conditions.explanation}`;

    await this.telegramService.sendMessage({
      chat_id: chatId,
      text: message,
      parse_mode: 'Markdown',
    });
  }


  /**
   * Handle test resume match command - uses test files for analysis
   */
  private async handleTestResumeMatch(chatId: number, _userId: number): Promise<void> {
    try {
      await this.telegramService.sendMessage({
        chat_id: chatId,
        text: 'üß™ **RUNNING TEST ANALYSIS**\n\nUsing test resume and job post files...\n\nThis will demonstrate the comprehensive analysis features.',
      });

      // Load test files (these should be the test files you provided)
      const testResume = this.documentService.processTextInput(this.getTestResumeText());
      const testJobPost = this.documentService.processTextInput(this.getTestJobPostText());

      console.log('Running test analysis with enhanced AI service...');
      const enhancedAnalysis = await this.enhancedAIService.analyzeResumeJobMatch(testResume, testJobPost);
      
      if (!enhancedAnalysis) {
        throw new Error('Test analysis failed');
      }

      await this.telegramService.sendMessage({
        chat_id: chatId,
        text: '‚úÖ **TEST ANALYSIS COMPLETED**\n\nHere are the results using our enhanced analysis system:',
      });

      await this.sendEnhancedAnalysisResults(chatId, enhancedAnalysis);

    } catch (error) {
      console.error('Error during test analysis:', error);
      await this.telegramService.sendMessage({
        chat_id: chatId,
        text: '‚ùå Test analysis failed: ' + (error as Error).message,
      });
    }
  }

  /**
   * Get test resume text
   */
  private getTestResumeText(): string {
    return `–ú—É–∂—á–∏–Ω–∞
–ü—Ä–æ–¥–∞–∫—Ç-–º–µ–Ω–µ–¥–∂–µ—Ä
40 –ª–µ—Ç  ‚Ä¢  –ë—ã–ª –≤—á–µ—Ä–∞
350 000 ‚ÇΩ
–ê–∫—Ç–∏–≤–Ω–æ –∏—â–µ—Ç —Ä–∞–±–æ—Ç—É
–ï—Å—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã–µ –Ω–∞–≤—ã–∫–∏
–ü–æ—Å–ª–µ–¥–Ω–µ–µ –º–µ—Å—Ç–æ —Ä–∞–±–æ—Ç—ã
ITV
–í–µ–¥—É—â–∏–π –ø—Ä–æ–¥–∞–∫—Ç-–º–µ–Ω–µ–¥–∂–µ—Ä  ‚Ä¢  –î–µ–∫–∞–±—Ä—å 2019 ‚Äî –ø–æ –Ω–∞—Å—Ç–æ—è—â–µ–µ –≤—Ä–µ–º—è
- –Ω–∞–ª–∞–∂–∏–≤–∞–Ω–∏–µ –∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∞ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã—Ö —Å–≤—è–∑–µ–π –º–µ–∂–¥—É –∫–æ–º–∞–Ω–¥–∞–º–∏, —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–Ω—ã—Ö –∫–æ–º–∞–Ω–¥ –¥–ª—è —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á.
- —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤.
- —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–∏–¥–µ–Ω–∏—è –æ–¥–Ω–æ–≥–æ –∏–∑ –æ—Å–Ω–æ–≤–Ω—ã—Ö –ø—Ä–æ–¥—É–∫—Ç–æ–≤ –∫–æ–º–ø–∞–Ω–∏–∏ –∏ –µ–≥–æ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ —Ä–∞–∑–≤–∏—Ç–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –∞–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∏ –¥–∞–Ω–Ω—ã—Ö, –æ—Ç –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤, –∫–ª–∏–µ–Ω—Ç–æ–≤ - —Ä—ã–Ω–∫–∞ –≤ —Ü–µ–ª–æ–º.
- —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å–∞–º–∏ –ø—Ä–æ–¥—É–∫—Ç–æ–≤–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –æ—Ç –≤—ã—è–≤–ª–µ–Ω–∏—è –ø–æ—Ç—Ä–µ–±–Ω–æ—Å—Ç–∏ –¥–æ –∞–Ω–∞–ª–∏–∑–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤.
- –ø—Ä—è–º–æ–µ –∏ –º–∞—Ç—Ä–∏—á–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥–∞–º–∏ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏, QA, PM, –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å –∫–æ–º–∞–Ω–¥–∞–º–∏ Support, project managers, marketing, –∫–æ–º–º–µ—Ä—á–µ—Å–∫–∏–º –¥–µ–ø–∞—Ä—Ç–∞–º–µ–Ω—Ç–∞. –°–æ —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–∞–º–∏ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏—Ö, –∫–æ–º–º–µ—Ä—á–µ—Å–∫–∏—Ö –ø–∞—Ä—Ç–Ω—ë—Ä–æ–≤ –∏ –∫–æ–Ω–µ—á–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤ —Ä–∞–∑–ª–∏—á–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è.
- –Ω–∞—Å—Ç–∞–≤–Ω–∏—á–µ—Å—Ç–≤–æ junior product managers
- –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á –≤ –∫–æ–º–∞–Ω–¥–µ –ø—Ä–æ–µ–∫—Ç–∞
- –ö–æ–Ω–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏—è —Ü–µ–ª–µ–π –ø—Ä–æ–µ–∫—Ç–∞ —Å–æ–≤–º–µ—Å—Ç–Ω–æ —Å –∑–∞–∫–∞–∑—á–∏–∫–æ–º –∏ –∑–∞–∏–Ω—Ç–µ—Ä–µ—Å–æ–≤–∞–Ω–Ω—ã–º–∏ —Å—Ç–æ—Ä–æ–Ω–∞–º–∏
- –í–µ–¥–µ–Ω–∏–µ –ø–æ–≤—Å–µ–¥–Ω–µ–≤–Ω—ã—Ö –≤—Å—Ç—Ä–µ—á, —Å–æ–≤–µ—â–∞–Ω–∏–π –∏ –æ–±—Å—É–∂–¥–µ–Ω–∏–π –≤ –∫–æ–º–∞–Ω–¥–µ
- –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–æ–ª–µ–π –∏ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏ –≤ –ø—Ä–æ–µ–∫—Ç–Ω–æ–π –∫–æ–º–∞–Ω–¥–µ
- –í–Ω–µ–¥—Ä–µ–Ω–∏–µ Agile- –∏ Scrum-–ø—Ä–∏–Ω—Ü–∏–ø–æ–≤ –∏ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –Ω–∞ —É—Ä–æ–≤–Ω–µ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è –∏–ª–∏ –∫–æ–º–ø–∞–Ω–∏–∏
- –î–æ—Ä–∞–±–æ—Ç–∫–∞ –∏ —Ä–∞–∑–≤–∏—Ç–∏–µ –ø—Ä–æ–¥—É–∫—Ç–∞ –ø–æ—Å–ª–µ –µ–≥–æ –∑–∞–ø—É—Å–∫–∞
- –ü–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–¥–∞—á –∫–æ–º–∞–Ω–¥–µ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –Ω–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é –∏–ª–∏ –¥–æ—Ä–∞–±–æ—Ç–∫—É –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–≥–æ –ø—Ä–æ–¥—É–∫—Ç–∞
- –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ, –¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏—è –∏ –∞–∫—Ç—É–∞–ª–∏–∑–∞—Ü–∏—è –±—ç–∫–ª–æ–≥–∞ –∑–∞–¥–∞—á –ø—Ä–æ–µ–∫—Ç–∞

- —Ä–∞–∑–≤–∏—Ç–∏–µ –∏ —Å–æ–∑–¥–∞–Ω–∏–µ b2b2c ‚Äì on premise –∏ cloud –ø—Ä–æ–¥—É–∫—Ç–æ–≤ –¥–ª—è CCTV –∏ SAS
- —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞, —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ, –ø—Ä–∏–æ—Ä–∏—Ç–∏–∑–∞—Ü–∏—è –∏ –≤–Ω–µ–¥—Ä–µ–Ω–∏–µ –≥–∏–ø–æ—Ç–µ–∑ –∏ –ø—Ä–æ–¥—É–∫—Ç–æ–≤
- –æ—Ü–µ–Ω–∫–∞, –ø—Ä–æ—Ä–∞–±–æ—Ç–∫–∞, –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –∫–æ–Ω—Ç—Ä–æ–ª—å –≤–Ω–µ–¥—Ä–µ–Ω–∏—è –Ω–æ–≤—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π, –∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–∞ –ø—Ä–æ–¥—É–∫—Ç–æ–≤:
–ê–¥–∞–ø—Ç–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã –¥–∞—à–±–æ—Ä–¥–æ–≤ –¥–ª—è –∑–∞–¥–∞—á —Ä–∏—Ç–µ–π–ª–∞, –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –∫–∞—Å—Å–æ–≤—ã–º –ü–û –∏ –ü–û –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏.
–†–∞–∑—Ä–∞–±–æ—Ç–∫–∞ –±—Ä–∏–¥–∂ —Ä–µ—à–µ–Ω–∏—è –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫–∞–º–µ—Ä –∏ –∫–∞—Å—Å–æ–≤—ã—Ö —Ç–µ—Ä–º–∏–Ω–∞–ª–æ–≤ –∫ –æ–±–ª–∞—á–Ω–æ–π –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–µ
–†–∞–∑—Ä–∞–±–æ—Ç–∫–∞ –Ω–æ–≤–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã VMS –ø—Ä–æ–¥—É–∫—Ç–∞, –Ω–∞ –±–∞–∑–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π —Ä—ã–Ω–∫–∞ –∏ –Ω–æ–≤—ã—Ö —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ä–µ—à–µ–Ω–∏–π
C–æ–∑–¥–∞–Ω–∏–µ Cloud –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –¥–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è Vsas –¥–ª—è –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤ –∫–æ–º–ø–∞–Ω–∏–∏ –Ω–∞ –±–∞–∑–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –ø—Ä–æ–¥—É–∫—Ç–∞, –≤–∫–ª—é—á–∞—è: –æ–±—â—É—é –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É –ø—Ä–æ–¥—É–∫—Ç–∞, frontend –∏ backend, –ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç, disaster recovery, multi tenancy, —Å–∏—Å—Ç–µ–º—É –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω—ã—Ö –æ—Ç—á–µ—Ç–æ–≤ –∏ –∞—É–¥–∏—Ç–∞ –¥–µ–π—Å—Ç–≤–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—é –ø—Ä–æ—Ü–µ—Å—Å–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–∞–º–µ—Ä –∏ –∏–Ω—Å—Ç–∞–Ω—Å–æ–≤, –ø–æ–¥–≥–æ—Ç–æ–≤–∫—É –º–∞—Ä–∫–µ—Ç–∏–Ω–≥–æ–≤—ã—Ö –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤ –∏ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫—É –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ –ø—Ä–æ–¥–∞–∂ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã. –ù–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –∫ Vsas –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞–º, —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–º –Ω–∞ –±–∞–∑–µ –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤, –≤ —Ç–æ–º —á–∏—Å–ª–µ —Ç–µ–ª–µ–∫–æ–º –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤ –ø–æ –≤—Å–µ–º—É –º–∏—Ä—É, –ø–æ–¥–∫–ª—é—á–µ–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ç—ã—Å—è—á —É—Å—Ç—Ä–æ–π—Å—Ç–≤. –°—Ä–µ–¥–∏ –Ω–∏—Ö –æ–¥–∏–Ω –∏–∑ –∫—Ä—É–ø–Ω–µ–π—à–∏—Ö —Ç–µ–ª–µ–∫–æ–º –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤ –ò–∑—Ä–∞–∏–ª—è.
–ì—Ä–∞–∂–¥–∞–Ω—Å—Ç–≤–æ
–†–æ—Å—Å–∏—è
–†–µ–≥–∏–æ–Ω –∏ –ø–µ—Ä–µ–µ–∑–¥
–ú–æ—Å–∫–≤–∞`;
  }

  /**
   * Get test job post text
   */
  private getTestJobPostText(): string {
    return `–í–µ–¥—É—â–∏–π –º–µ–Ω–µ–¥–∂–µ—Ä –ø–æ –ø—Ä–æ–¥–∞–∂–∞–º / Senior sales manager. Programmatic-iTV
–°—Ç–∞–Ω–¥–∞—Ä—Ç
–ò—Å—Ç–µ–∫–∞–µ—Ç 03.10
–ú–æ—Å–∫–≤–∞¬∑–û–ø—ã—Ç 3‚Äì6 –ª–µ—Ç¬∑–æ—Ç 280 000 –¥–æ 350 000 ‚ÇΩ –∑–∞ –º–µ—Å—è—Ü, –Ω–∞ —Ä—É–∫–∏

Between Exchange ‚Äì –∫—Ä—É–ø–Ω–µ–π—à–∞—è —Ä–µ–∫–ª–∞–º–Ω–∞—è –±–∏—Ä–∂–∞. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º SSP –∏ DSP –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å –Ω–∞ –±–æ–ª–µ–µ —á–µ–º 100 000 –ø–ª–æ—â–∞–¥–æ–∫. –†—É–Ω–µ—Ç + –ê–∑–∏—è. –ù–∞ –¥–µ—Å–∫—Ç–æ–ø–µ, –≤ –º–æ–±–∞–π–ª–µ –∏ Smart TV.

–û–±—è–∑–∞–Ω–Ω–æ—Å—Ç–∏:
–ö–æ–Ω–∞–∫—Ç—ã, –≤—Å—Ç—Ä–µ—á–∏, –±—Ä–∏—Ñ—ã, –∫–æ–º–º–µ—Ä—á–µ—Å–∫–∏–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è
–ó–∞–∫—Ä—ã—Ç–∏–µ —Å–¥–µ–ª–æ–∫

–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è:
–æ–ø—ã—Ç —Å tv-—Ä–µ–∫–ª–∞–º–æ–π
–æ–ø—ã—Ç –≤ –ø—Ä–æ–¥–∞–∂–∞—Ö —Å –¥–ª–∏–Ω–Ω—ã–º —Ü–∏–∫–ª–æ–º —Å–¥–µ–ª–∫–∏
–•–æ—Ä–æ—à–æ –ø–æ–Ω–∏–º–∞—Ç—å –≥–¥–µ –ª–µ–∂–∞—Ç –∏ –∫–µ–º —Ä–∞—Å–ø—Ä–µ–¥–µ–ª—è—é—Ç—Å—è –ø–µ—Ä—Ñ–æ–º–∞–Ω—Å–Ω—ã–µ, –æ—Ö–≤–∞—Ç–Ω—ã–µ –∏ –º–µ–¥–∏–π–Ω—ã–µ –±—é–¥–∂–µ—Ç—ã —Ä–µ–∫–ª–∞–º–æ–¥–∞—Ç–µ–ª–µ–π –∏ —Ä–µ–∫–ª–∞–º–Ω—ã—Ö –∞–≥–µ–Ω—Ç—Å—Ç–≤.
–ò–º–µ—Ç—å –Ω–∞–ª–∞–∂–µ–Ω–Ω—ã–µ, –∏–¥–µ–∞–ª—å–Ω–æ –µ—Å–ª–∏ –¥—Ä—É–∂–µ—Å–∫–∏–µ –æ—Ç–Ω–æ—à–µ–Ω–∏—è —Å –ª–∏—Ü–∞–º–∏ –ø—Ä–∏–Ω–∏–º–∞—é—â–∏–º–∏ —Ä–µ—à–µ–Ω–∏—è —Å–∞–º–æ–≥–æ –≤—ã—Å–æ–∫–æ–≥–æ —É—Ä–æ–≤–Ω—è —Ä–µ–∫–ª–∞–º–Ω—ã—Ö –∞–≥–µ–Ω—Ç—Å—Ç–≤ –∏ –∫—Ä—É–ø–Ω–µ–π—à–∏—Ö —Ä–µ–∫–ª–∞–º–æ–¥–∞—Ç–µ–ª–µ–π (CEO, CMO, CPO, –∞–∫—Ü–∏–æ–Ω–µ—Ä—ã) –∏ –¢–û–ü-–º–µ–Ω–µ–¥–∂–µ—Ä–∞–º–∏ Tier 2, –∫–æ—Ç–æ—Ä—ã–µ –æ—Ç–≤–µ—á–∞—é—Ç –∑–∞ –∑–∞—Ä–∞–±–æ—Ç–æ–∫ —Ä–µ–∫–ª–∞–º–Ω—ã—Ö –∞–≥–µ–Ω—Ç—Å—Ç–≤

–£—Å–ª–æ–≤–∏—è:
–•–æ—Ä–æ—à–∏–π –æ–∫–ª–∞–¥ + –ø—Ä–æ—Ü–µ–Ω—Ç —Å –ø—Ä–æ–¥–∞–∂
–û—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ –ø–æ —Ç–∫ —Ä—Ñ

–ö–ª—é—á–µ–≤—ã–µ –Ω–∞–≤—ã–∫–∏
B2B –ü—Ä–æ–¥–∞–∂–∏
–ú–µ–¥–∏–π–Ω–∞—è —Ä–µ–∫–ª–∞–º–∞
–ê–∫—Ç–∏–≤–Ω—ã–µ –ø—Ä–æ–¥–∞–∂–∏
Digital Marketing
–ö–æ–Ω—Å—É–ª—å—Ç–∞—Ç–∏–≤–Ω—ã–µ –ø—Ä–æ–¥–∞–∂–∏
–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫–æ–º–º–µ—Ä—á–µ—Å–∫–∏—Ö –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π
–¢–µ–ø–ª—ã–µ –ø—Ä–æ–¥–∞–∂–∏
SPIN-–ø—Ä–æ–¥–∞–∂–∏
–ö–æ–Ω—Å—É–ª—å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–æ–≤

–ì–¥–µ –ø—Ä–µ–¥—Å—Ç–æ–∏—Ç —Ä–∞–±–æ—Ç–∞—Ç—å
–ö—É–∑–Ω–µ—Ü–∫–∏–π –º–æ—Å—Ç, –õ—É–±—è–Ω–∫–∞, –¶–≤–µ—Ç–Ω–æ–π –±—É–ª—å–≤–∞—Ä, –ú–æ—Å–∫–≤–∞, –¢—Ä—É–±–Ω–∞—è –ø–ª–æ—â–∞–¥—å`;
  }

  /**
   * Send welcome message
   */
  private async sendWelcomeMessage(chatId: number): Promise<void> {
    const sent = await this.telegramService.sendMessage({
      chat_id: chatId,
      text: 'üëã Welcome to Resume Matcher Bot!\n\nI help you analyze how well your resume matches job descriptions using AI.\n\nüöÄ To get started, send:\n/resume_and_job_post_match\n\n‚ùì Need help? Send /help',
    });
    if (sent) {
      await this.loggingService.logBotResponse(0, chatId, 'Welcome message sent');
    } else {
      await this.loggingService.logError('SEND_MESSAGE_FAILED', 'Failed to send welcome message', new Error('sendMessage returned false'), 0, chatId);
    }
  }

  /**
   * Send help message
   */
  private async sendHelpMessage(chatId: number): Promise<void> {
    const sent = await this.telegramService.sendMessage({
      chat_id: chatId,
      text: 'ü§ñ Resume Matcher Bot Commands\n\n/resume_and_job_post_match - Start resume analysis\n/help - Show this help message\n/cancel - Cancel current process\n\nOr just type "help match resume" to get started!',
    });
    if (sent) {
      await this.loggingService.logBotResponse(0, chatId, 'Help message sent');
    } else {
      await this.loggingService.logError('SEND_MESSAGE_FAILED', 'Failed to send help message', new Error('sendMessage returned false'), 0, chatId);
    }
  }

  /**
   * Cancel current process
   */
  private async cancelCurrentProcess(chatId: number, userId: number): Promise<void> {
    await this.sessionService.completeSession(userId);
    await this.telegramService.sendMessage({
      chat_id: chatId,
      text: '‚úÖ Process cancelled. You can start a new analysis anytime with /resume_and_job_post_match',
    });
  }

  /**
   * Get environment-specific admin help message
   */
  private getAdminHelpMessage(command: string): string {
    let environmentInfo = '';
    
    if (this.environment === 'staging') {
      environmentInfo = `\n\nüîß **Staging Environment**\nPassword: \`${this.adminPassword}\``;
    } else {
      environmentInfo = '\n\nüîí **Secure Environment**\nAsk the developer for the password.';
    }

    return `üîë **Admin Command Help**\n\nUsage: \`${command} <password>\`${environmentInfo}\n\nüìã **Available Commands:**\n‚Ä¢ \`/get_last_10_messages <password>\`\n‚Ä¢ \`/get_last_100_messages <password>\`\n‚Ä¢ \`/log_summary <password>\``;
  }

  /**
   * Simple password check for admin commands
   */
  private checkPassword(password: string): boolean {
    return password === this.adminPassword;
  }

  /**
   * Get environment-specific invalid password message
   */
  private getInvalidPasswordMessage(): string {
    if (this.environment === 'staging') {
      return `‚ùå Invalid password for staging environment.\n\nüîë **Staging Password**: \`${this.adminPassword}\`\n\nüí° For staging, use: \`/get_last_10_messages ${this.adminPassword}\``;
    } else if (this.environment === 'production') {
      return `‚ùå Invalid password for production environment.\n\nüîí **Production Access**: Contact the developer for the secure password.`;
    } else {
      return `‚ùå Invalid password for development environment.\n\nüõ†Ô∏è **Development Password**: \`${this.adminPassword}\``;
    }
  }

  /**
   * Handle simplified log command with inline password
   */
  private async handleSimpleLogCommand(fullText: string, chatId: number, userId: number, limit: number): Promise<void> {
    try {
      // Parse command: /get_last_10_messages password
      const parts = fullText.trim().split(/\s+/);
      const password = parts[1];

      if (!password) {
        const helpMessage = this.getAdminHelpMessage(`/get_last_${limit}_messages`);
        const sent = await this.telegramService.sendMessage({
          chat_id: chatId,
          text: helpMessage,
        });
        if (sent) {
          await this.loggingService.logBotResponse(userId, chatId, 'Admin help message');
        } else {
          await this.loggingService.logError('SEND_MESSAGE_FAILED', 'Failed to send admin help message', new Error('sendMessage returned false'), userId, chatId);
        }
        return;
      }

      if (!this.checkPassword(password)) {
        const errorMessage = this.getInvalidPasswordMessage();
        const sent = await this.telegramService.sendMessage({
          chat_id: chatId,
          text: errorMessage,
        });
        if (sent) {
          await this.loggingService.logBotResponse(userId, chatId, errorMessage);
        } else {
          await this.loggingService.logError('SEND_MESSAGE_FAILED', 'Failed to send invalid password message', new Error('sendMessage returned false'), userId, chatId);
        }
        await this.loggingService.log('WARN', 'LOG_ACCESS_DENIED', 'Invalid password for log access', { limit }, userId, chatId);
        return;
      }

      // Send "loading" message
      const loadingSent = await this.telegramService.sendMessage({
        chat_id: chatId,
        text: `üìä Fetching last ${limit} log messages...`,
      });
      if (loadingSent) {
        await this.loggingService.logBotResponse(userId, chatId, `üìä Fetching last ${limit} log messages...`);
      } else {
        await this.loggingService.logError('SEND_MESSAGE_FAILED', 'Failed to send loading message', new Error('sendMessage returned false'), userId, chatId);
        return; // Don't continue if we can't send messages
      }

      // Get formatted logs
      const formattedLogs = await this.loggingService.getFormattedRecentLogs(limit, this.environment);

      // Send logs
      const logsSent = await this.telegramService.sendMessage({
        chat_id: chatId,
        text: formattedLogs,
      });
      if (logsSent) {
        await this.loggingService.logBotResponse(userId, chatId, 'Log results sent');
      } else {
        await this.loggingService.logError('SEND_MESSAGE_FAILED', 'Failed to send log results', new Error('sendMessage returned false'), userId, chatId);
      }

      // Log access
      await this.loggingService.log('INFO', 'LOG_ACCESS_SUCCESS', `Viewed last ${limit} messages`, { limit }, userId, chatId);

    } catch (error) {
      await this.loggingService.logError('LOG_ACCESS_ERROR', 'Error viewing logs', error as Error, userId, chatId);
      await this.telegramService.sendMessage({
        chat_id: chatId,
        text: '‚ùå Error retrieving logs. Please try again.',
      });
    }
  }

  /**
   * Handle simplified log summary command with inline password
   */
  private async handleSimpleLogSummaryCommand(fullText: string, chatId: number, userId: number): Promise<void> {
    try {
      // Parse command: /log_summary password
      const parts = fullText.trim().split(/\s+/);
      const password = parts[1];

      if (!password) {
        const helpMessage = this.getAdminHelpMessage('/log_summary');
        await this.telegramService.sendMessage({
          chat_id: chatId,
          text: helpMessage,
        });
        return;
      }

      if (!this.checkPassword(password)) {
        const errorMessage = this.getInvalidPasswordMessage();
        await this.telegramService.sendMessage({
          chat_id: chatId,
          text: errorMessage,
        });
        await this.loggingService.log('WARN', 'LOG_SUMMARY_ACCESS_DENIED', 'Invalid password for log summary access', {}, userId, chatId);
        return;
      }

      // Send "loading" message
      const loadingSent = await this.telegramService.sendMessage({
        chat_id: chatId,
        text: 'üìä Generating log summary...',
      });
      if (loadingSent) {
        await this.loggingService.logBotResponse(userId, chatId, 'üìä Generating log summary...');
      } else {
        await this.loggingService.logError('SEND_MESSAGE_FAILED', 'Failed to send loading message', new Error('sendMessage returned false'), userId, chatId);
        return; // Don't continue if we can't send messages
      }

      // Get log summary
      const summary = await this.loggingService.getAdminLogSummary(24);

      const summarySent = await this.telegramService.sendMessage({
        chat_id: chatId,
        text: summary,
      });
      if (summarySent) {
        await this.loggingService.logBotResponse(userId, chatId, 'Log summary sent');
      } else {
        await this.loggingService.logError('SEND_MESSAGE_FAILED', 'Failed to send log summary', new Error('sendMessage returned false'), userId, chatId);
      }

      // Log access
      await this.loggingService.log('INFO', 'LOG_SUMMARY_SUCCESS', 'Viewed log summary', {}, userId, chatId);

    } catch (error) {
      await this.loggingService.logError('LOG_SUMMARY_ERROR', 'Error generating log summary', error as Error, userId, chatId);
      await this.telegramService.sendMessage({
        chat_id: chatId,
        text: '‚ùå Error generating log summary. Please try again.',
      });
    }
  }
}
